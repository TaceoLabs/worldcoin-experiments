\documentclass[a4paper,11pt,
    %final, % to remove the draft watermark
]{article}

\usepackage[a4paper, top=3.5cm, bottom=3.5cm,
  left=3cm, right=3cm]{geometry}
\usepackage[parfill]{parskip}

%%% PACKAGES
\usepackage[ngerman,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{microtype}
\usepackage[all]{nowidow}

% Useful packages for complex content:
\usepackage{amsmath,amsfonts,amssymb} % typesetting math
\usepackage{tikz}                    % typesetting diagrams, figures, ...
\usepackage{siunitx}                 % typesetting SI-units and formatted numbers
\usepackage{booktabs,multirow}       % utils for complex/beautiful tables
\usepackage{subcaption}              % placing multiple subfigures in a figure
\usepackage{draftwatermark}          % to add a draft watermark

\SetWatermarkText{DRAFT}
\SetWatermarkScale{4}
\SetWatermarkLightness{0.9}

% Bibliography, referencing, and indexing
\usepackage{csquotes}                 % typesetting \enquote{text in quotes} correctly
\usepackage[backend=biber,
    style=alphabetic,
    minalphanames=3, maxalphanames=4,
    maxbibnames=20]{biblatex} % to generate the bibliography
\addbibresource{report.bib}

%--- THIRD PARTY PACKAGES ------------------------------------------------------

\usepackage{float}
\usepackage{color}
\usepackage{graphicx}
\usepackage{svg}
\usepackage{mathrsfs}
\usepackage{bm}
\usepackage{comment}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{bigdelim}
\usepackage[obeyDraft,obeyFinal]{todonotes}
\usepackage{colortbl}
\usepackage{xfrac}
\usepackage{mleftright}
\usepackage{nth}
\usepackage{breakcites}
\usepackage{pdfpages}
\usepackage{xspace}
\usepackage{placeins}
\usepackage{setspace}
\usepackage[n, advantage , operators ,
    sets ,
    adversary ,
    landau ,
    probability ,
    notions ,
    logic ,
    ff ,
    mm,
    primitives ,
    events ,
    complexity ,
    asymptotics ,
    keys
]{cryptocode}
\usepackage{numprint}
\npdecimalsign{.}
\npthousandsep{\,}
\usepackage{dblfloatfix}

\usepackage{mdframed}

% for the table footnote
\usepackage{enumitem}
\usepackage[referable]{threeparttablex}
\renewlist{tablenotes}{enumerate}{1}
\makeatletter
\setlist[tablenotes]{label=\tnote{\alph*},ref=\alph*,itemsep=\z@,topsep=\z@skip,partopsep=\z@skip,parsep=\z@,itemindent=\z@,labelindent=\tabcolsep,labelsep=.2em,leftmargin=*,align=left,before={\footnotesize}}
\makeatother

% tikz
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{tikzscale}
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{math}
\usetikzlibrary{matrix}
\usetikzlibrary{patterns}
\usetikzlibrary{shadows}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{fit}
\usetikzlibrary{automata}
\usetikzlibrary{circuits.logic.US}
\tikzset{>=stealth}
\tikzset{font={\fontsize{9pt}{12}\selectfont}}

\usepackage{fontawesome}
\usepackage{pgffor}
\newcommand{\stars}[1]{
    \foreach \n in {1,...,5}{\ifnum \n>#1\faStarO\else\faStar\fi}%
}

\usepackage{hyperref}
\usepackage{cleveref}
\crefformat{footnote}{#2\footnotemark[#1]#3}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% macros
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\F}{\ensuremath{\mathbb{F}}\xspace}
\newcommand{\G}{\ensuremath{\mathbb{G}}\xspace}
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\R}{\ensuremath{\mathbb{R}}\xspace}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\T}{\ensuremath{\mathbb{T}}\xspace}
\newcommand{\B}{\ensuremath{\mathbb{B}}\xspace}
\newcommand{\Ring}{\ensuremath{\mathcal{R}\xspace}}
\newcommand{\ctrans}{\ensuremath{\mathsf{CTrans}}} % 2008
\newcommand{\centercell}[1]{\multicolumn{1}{c}{#1}}
\newcommand{\centercellR}[1]{\multicolumn{1}{c|}{#1}}
\newcommand*{\numero}{n\kern-.1em \raise.7ex\vbox{\hbox{\tiny \ensuremath{\circ}}\kern.5pt}}
\newcommand{\todoi}[1]{\todo[inline]{#1}}

\newcommand{\getsr}{\stackrel{\$}{\gets}}
\newcommand{\checkeq}{\stackrel{?}{=}}

\newcommand{\msg}{\ensuremath{\mathsf{msg}}}
\newcommand{\pubp}{\ensuremath{\mathsf{pp}}}
\newcommand{\ct}{\ensuremath{\mathsf{ct}}}
\newcommand{\tx}{\ensuremath{\mathsf{tx}}}
\newcommand{\cn}{\ensuremath{\mathsf{cn}}}
\newcommand{\ck}{\ensuremath{\mathsf{ck}}}
\newcommand{\act}{\ensuremath{\mathsf{act}}}
\newcommand{\ask}{\ensuremath{\mathsf{ask}}}
\newcommand{\Setup}{\ensuremath{\mathsf{Setup}}}
\newcommand{\Open}{\ensuremath{\mathsf{Open}}}
\newcommand{\KeyGen}{\ensuremath{\mathsf{KeyGen}}}
\newcommand{\Mint}{\ensuremath{\mathsf{Mint}}}
\newcommand{\Spend}{\ensuremath{\mathsf{Spend}}}
\newcommand{\Verify}{\ensuremath{\mathsf{Verify}}}
\newcommand{\Encaps}{\ensuremath{\mathsf{Encaps}}}
\newcommand{\Decaps}{\ensuremath{\mathsf{Decaps}}}
\newcommand{\Com}{\ensuremath{\mathsf{Com}}}
\newcommand{\com}{\ensuremath{\mathsf{com}}}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}}
\newcommand{\aux}{\ensuremath{\mathsf{aux}}}
\newcommand{\mask}{\ensuremath{\mathsf{mask}}}
\newcommand{\shared}[1]{\ensuremath{[\![{#1}]\!]}}
\newcommand{\sharedB}[1]{\ensuremath{[\![{#1}]\!]^B}}

%\newcommand{\bin}{\{0,1\}}

\newcommand{\daniel}[1]{\todo[inline,color=cyan!40!white]{Daniel: #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% floats
\floatstyle{boxed}
\newfloat{scheme}{ht}{sc}
\floatname{scheme}{Scheme}
\Crefname{scheme}{Scheme}{Schemes}
\newfloat{functionality}{ht}{fc}
\floatname{functionality}{Functionality}
\Crefname{functionality}{Functionality}{Functionalities}

\expandafter\def\expandafter\UrlBreaks\expandafter{\UrlBreaks%  save the current one
    \do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j%
    \do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t%
    \do\u\do\v\do\w\do\x\do\y\do\z\do\A\do\B\do\C\do\D%
    \do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N%
    \do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X%
    \do\Y\do\Z}

\setlength{\tabcolsep}{6pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Experiments for Decentralized Iris Code Membership Protocols using MPC}


\date{January 2024}

\author{TACEO}

\maketitle

\begin{abstract}
    This report
\end{abstract}

\section{Introduction}

\section{Preliminaries}

\subsection{MPC Protocols}\label{sec:prelim:mpc}

\section{Iris Code Membership Protocol}

\subsection{Core Building Block: Efficient Dot Product}

One of the core operations of the Iris Code Membership protocol is the calculation of the hamming distance of the two binary iris code vectors. Calculating the hamming weight of a binary vector in a trivial fashion would require communication that is linear in the length of the vector. However, if we have the precondition that the input vector is already shared over a larger ring $\Z_{2^k}$ instead of $\F_2$, we can employ the following strategy:

\[
    \mathsf{hd}(\vec{a}, \vec{b}) = \sum_i a_i - 2\sum_i a_i \cdot b_i + \sum_i b_i\,.
\]

This reduces the calculation of the hamming distance to two sums (which can be computed without party interaction in most MPC protocols), as well as a dot-product of two vectors.
The calculation of this dot-product dominates the complexity of the hamming-distance operation, and we therefore want to use MPC protocols that support a very efficient dot-product operation.
In general, protocols that have a honest-majority security assumption can support dot-products that require communication which is independent of the size of the vectors, which is optimal.
The protocols we discuss in \Cref{sec:prelim:mpc} all support such efficient dot-products.

\subsection{Core Building Block: MSB Extraction}

Since a comparison $a < b$ is equal to an MSB-extraction $\texttt{msb}(a-b)$ (if the sizes of $a,b$ are chosen to not produce an overflow), a core building block is an MSB-extraction protocol. This subprotocol requires to change the sharing type of additive shares over $\Z_{2^k}$ to boolean shares over $\F_2^k$. In the targeted honest-majority MPC protocols (\Cref{sec:prelim:mpc}) this is usually done by interpreting each additive share $x_i \in \Z_{2^k}$ of $\shared{x}=(x_1, x_2, x_3)$ as a trivial boolean share. In other words, the shares are translated to $\sharedB{x_1} = (x_1, 0, 0)$, $\sharedB{x_2} = (0, x_2, 0)$, and $\sharedB{x_3} = (0, 0, x_3)$. Finally, these three shares are  combined to the target share by computing $\sharedB{x_1} + \sharedB{x_2} + \sharedB{x_3}$ using a binary adder circuit in MPC. Thereby, one can use the following optimization: If one first computes a full adder $\texttt{FA}(\sharedB{x_1[i]}, \sharedB{x_2[i]}, \sharedB{x_3[i]}) = (\sharedB{c[i]}, \sharedB{s[i]})$ for each bit $i$ ($k$ And gates and depth of only one), the final result can be obtained by adding $2 \cdot \sharedB{c} + \sharedB{s}$. This drastically reduces the total number of communication rounds required for the binary circuit.
Finally, since the use case operates on a huge amount of data, $k$ being small, and reducing communication complexity being the primary optimization point, we opt for using a ripple-carry-adder instead of a depth-optimized carry-lookahead adder for computing $2 \cdot \sharedB{c} + \sharedB{s}$.


\subsection{Core Building Block: Or-tree}

After all hamming distances are compared to the thresholds, one needs to accumulate all resulting bits. Since the result should be zero iff all bits are zero, the accumulation is equivalent to an boolean Or operation. In MPC, one can compute an $x \vee y = x \xor y \xor (x \wedge y)$. To reduce the number of communication rounds, we evaluate the accumulation of all bits as a binary tree.

\section{Experiments}

\subsection{Benchmarks}

\section{Conclusion and Open Problems}

\subsection{Open Problems and Bottlenecks}

\paragraph{Size of the Shared Iris Database}
Due to the requirements for the efficient dot-product operation, the iris database needs to be shared over a ring of size $2^k$ for some $k$, such that the summations do not overflow the ring.
For the example parameters of an iris code length of 12800, this means that $k$ is at least 14, and for simplicity we choose $k=16$.

\printbibliography

\end{document}
